"""
This module provides classes for loading datasets generated by DataGenerator.
"""
import glob
import os
from dataclasses import dataclass
import json
import geopandas as gpd
import numpy as np

from ..utils.logging_setup import get_logger

log = get_logger()

@dataclass
class SARDatasetItem:
    """
    A dataclass to hold the data for a single generated SAR environment quantile.

    Attributes:
        quantile (str): The name of the quantile (e.g., 'q1', 'median').
        center_point (tuple[float, float]): The (longitude, latitude) of the dataset's center.
        radius_km (float): The radius used to generate this dataset item.
        features (gpd.GeoDataFrame): A GeoDataFrame containing all geographic features.
        heatmap (np.ndarray): A 2D NumPy array representing the probability heatmap.
    """
    quantile: str
    center_point: tuple[float, float]
    radius_km: float
    features: gpd.GeoDataFrame
    heatmap: np.ndarray


class DatasetLoader:
    """
    Loads SAR environment datasets from a specified directory.

    This class is designed to load files created by the
    DataGenerator's export_all_quantiles method.
    """

    def __init__(self, dataset_directory: str):
        """
        Initializes the DatasetLoader.

        Args:
            dataset_directory (str): The path to the directory containing the dataset files.
        """
        if not os.path.isdir(dataset_directory):
            log.error(f"Dataset directory not found at: {dataset_directory}")
            raise FileNotFoundError(f"The specified directory does not exist: {dataset_directory}")

        self.dataset_directory = dataset_directory

        self.quantile_radii_km = {
            'q1': 0.6, 'median': 1.8, 'q3': 3.2, 'q95': 9.9,
        }


    def _get_file_paths(self, quantile: str) -> tuple[str | None, str | None]:
        """Constructs and validates file paths for a given quantile."""
        if quantile not in self.quantile_radii_km:
            log.warning(f"Quantile '{quantile}' is not a valid quantile name.")
            return None, None

        geojson_path = os.path.join(self.dataset_directory, f"features_{quantile}.geojson")
        heatmap_path = os.path.join(self.dataset_directory, f"heatmap_{quantile}.npy")

        if not os.path.exists(geojson_path):
            log.warning(f"GeoJSON file not found for quantile '{quantile}' at: {geojson_path}")
            geojson_path = None

        if not os.path.exists(heatmap_path):
            log.warning(f"Heatmap file not found for quantile '{quantile}' at: {heatmap_path}")
            heatmap_path = None

        return geojson_path, heatmap_path

    def get_available_quantiles(self) -> list[str]:
        """
        Scans the dataset directory and returns a list of quantiles
        that have both a features and heatmap file available.
        """
        available = []
        for q_name in self.quantile_radii_km:
            geojson_path, heatmap_path = self._get_file_paths(q_name)
            if geojson_path and heatmap_path:
                available.append(q_name)
        return available

    def load_quantile(self, quantile: str) -> SARDatasetItem | None:
        """
        Loads the data for a single specified quantile. It reads the center_point
        metadata directly from the GeoJSON file.

        Args:
            quantile (str): The name of the quantile to load (e.g., 'median').

        Returns:
            SARDatasetItem | None: A dataclass instance containing the loaded data.
        """
        log.info(f"Attempting to load data for quantile: '{quantile}'")
        geojson_path, heatmap_path = self._get_file_paths(quantile)

        if not geojson_path or not heatmap_path:
            log.error(f"Cannot load quantile '{quantile}' due to missing files.")
            return None

        try:
            # First, load the geojson as a dictionary to get the metadata
            with open(geojson_path, 'r') as f:
                geojson_data = json.load(f)

            # Extract the embedded center point
            center_point = tuple(geojson_data['center_point'])

            # Now, create the GeoDataFrame from the 'features' part of the dictionary
            features = gpd.GeoDataFrame.from_features(geojson_data["features"], crs="EPSG:4326")

            heatmap = np.load(heatmap_path)
            radius = self.quantile_radii_km[quantile]

            log.info(f"Successfully loaded data for quantile '{quantile}'.")
            return SARDatasetItem(
                quantile=quantile,
                center_point=center_point,
                radius_km=radius,
                features=features,
                heatmap=heatmap
            )
        except KeyError:
            log.error(f"Could not find 'center_point' key in {geojson_path}. The file might be from an old export.")
            return None
        except Exception as e:
            log.error(f"An error occurred while loading files for quantile '{quantile}': {e}", exc_info=True)
            return None

    def load_all(self) -> dict[str, SARDatasetItem]:
        """
        Loads all available quantiles found in the dataset directory.

        Returns:
            dict[str, SARDatasetItem]: A dictionary where keys are quantile names
                                       and values are the corresponding SARDatasetItem objects.
        """
        log.info("Loading all available quantiles from the dataset directory.")
        all_data = {}
        available_quantiles = self.get_available_quantiles()

        if not available_quantiles:
            log.warning("No complete quantile data found in the specified directory.")
            return {}

        for quantile in available_quantiles:
            item = self.load_quantile(quantile)
            if item:
                all_data[quantile] = item

        return all_data
